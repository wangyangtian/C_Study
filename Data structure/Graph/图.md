# 图的定义
图G由顶点集和边集E组成，记为$G=(V,E)$.

# 图的存储
## 邻接矩阵法
![alt text](Image/邻接矩阵法.png)
```c
#define MAXVERTEXNUM 100
#define INFINITY INT_MAX
typedef struct 
{
    char Vex[MAXVERTEXNUM]; //顶点表
    int Edge[MAXVERTEXNUM][MAXVERTEXNUM];//邻接矩阵，边表
    int vexnum,arcnum;  //当前顶点数和弧数
}MGraph;
```
**图的邻接矩阵存储表示法具有以下特点:**
①无向图的邻接矩阵一定是一个对称矩阵(并且唯一)。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。
②对于无向图，邻接矩阵的第$i$行（或第$i$列）非零元素（或非$\infty$元素）的个数正好是顶点$i$的度$TD(v_i)$。
③对于有向图，邻接矩阵的第$i$行非零元素（或非$\infty$元素）的个数正好是顶点$i$的出度$OD(v_i)$;第$i$列非零元素(或非元素)的个数正好是顶点$i$的入度 $ID(v_i)$。
④用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。
⑤稠密图(即边数较多的图)适合采用邻接矩阵的存储表示。
⑥设图$G$的邻接矩阵为$A$，$A^n$的元素$A^n[i][j]$等于由顶点$i$到顶点$j$的长度为$n$的路径的数目。

## 邻接表法
```c
typedef struct ArcNode{     //边
    int adjvex;             //弧指向的结点
    struct ArcNode *next;   //指向下一条弧的指针
    //int Info;             //边权值   
}ArcNode;

typedef struct VNode{   //顶点
    char data;          //顶点信息   
    ArcNode *first;     //指向第一条弧的指针
}VNode,AdjList[MAXVERTEXNUM];

typedef struct ALGraph
{
    AdjList vertices;
    int vexnum,arcnum;
};
```
**图的邻接表存储方法具有以下特点:**
①若$G$为无向图，则所需的存储空间为$O(|V|+2|E|)$;若$G$为有向图,则所需的存储空间为$O(|V|+2|E|)$。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。
②对于稀疏图(即边数较少的图)，采用邻接表表示将极大地节省存储空间。
③在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为$O(n)$。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。
④在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点x的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为x的边表结点个数。
⑤图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。


# 图的遍历
## 广度优先遍历(BFS)
**要点:**
1. 找到与一个顶点相邻的所有顶点
2. 标记哪些顶点被访问过
3. 需要一个辅助队列

- FirstNeighbor(G,x):求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。

- `bool visited [MAX_VERTEX_NUM];//访问标记数组`
