> (1)将串str中所有值为ch1的字符转换成ch2 的字符，如果str为空串，或者串中不含值为chl的字符，则什么都不做。
(2)实现串str的逆转函数，如果str为空串，则什么都不做。
(3)删除str中值为ch 的所有字符，如果str为空串，或者串中不含值为ch的子付，则什么都个饿。
(4)从串str中的pos位置起，求出与substr串匹配的子串的位置，如果str 为空串，或者串中不含与substr匹配的子串，则返回-1做标记。

```c
void Ch1toCh2(char* str, int ch1, int ch2) {
    if (!*str)
        return;
    while (*str != '\0') {
        if (*str == ch1) {
            *str = ch2;
        }
        str++;
    }
}

void ReverseString(char* str, int len) {
    char* front = str;
    char* rear = str + len - 1;
    if (!str)
        return;

    while (front < rear) {
        char temp = *front;
        *front = *rear;
        *rear = temp;
        front++;
        rear--;
    }
}
char* DeleteCh(char* str, char ch) {
    if (!str)
        return str;
    char* newstr = str;
    char* start = str;
    while (*str) {
        if (*str != ch) {
            *newstr = *str;
            newstr++;
        }
        str++;
    }
    *newstr = '\0';
    return start;
}

int FindSubString(const char* str, const char* substr, int pos) {
    if (str == NULL || substr == NULL || pos < 0) {
        return -1;
    }

    int lenStr = strlen(str);
    int lenSubstr = strlen(substr);

    if (pos > lenStr || lenStr == 0) {
        return -1;
    }

    for (int i = pos; i <= lenStr - lenSubstr; i++) {
        int j;
        for (j = 0; j < lenSubstr; j++) {
            if (*(str + i + j) != *(substr + j)) {
                break;
            }
        }
        if (j == lenSubstr) {  // 完整匹配后才返回
            return i;
        }
    }
    return -1;  // 未找到匹配的子串
}
```

> 2．采用定长顺序存储表示串，编写一个函数，删除串中从下标为i的字符开始的j个字符，如果下标为i的字符后没有足够的j个字符，则有几个删除几个。
```c
void DeleteI2J(SString* s, unsigned int i, unsigned int j) {
    if ((int)i > s->length)
        return;

    if (j <= s->length - i) {
        while (i <= s->length - j) {
            s->ch[i] = s->ch[i + j];
            i++;
        }
        s->length = s->length - j;
    } else {
        s->length = i + 1;
    }
}
```

